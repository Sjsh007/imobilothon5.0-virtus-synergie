#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <base64.h> 
#include <TinyGPSPlus.h>
#include <HardwareSerial.h>

const char* ssid = "Kibo_AirFiber";
const char* password = "kibo@123";

// --- Twilio API Credentials ---
const char* accountSID = "ACXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"; 
const char* authToken  = "YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"; 
const char* fromNumber = "XXXXXXXXXX"; // Your Twilio Number
const char* toNumber   = "YYYYYYYYYY"; // Your Verified 'To' Number
const char* host = "api.twilio.com";
const int httpsPort = 443;


// --- Hardware Pins ---
const int ENA = 25;    
const int IN1 = 26;    
const int IN2 = 27;    
#define LED_PIN 4      
const int potPin = 34;   
const int buzzerPin = 2;  

// --- GPS Settings ---
static const int RXPin = 16; 
static const int TXPin = 17; 
static const uint32_t GPSBaud = 9600;
TinyGPSPlus gps;
HardwareSerial SerialGPS(2); 

// --- Motor Settings ---
const uint8_t MAX_DUTY = 160;
const unsigned long RAMP_DOWN_TIME = 10000; // 10 seconds
const unsigned long RAMP_DOWN_INTERVAL = RAMP_DOWN_TIME / MAX_DUTY; 

// --- Steering Monitor Settings ---
const float EMA_ALPHA = 0.2f;   
const int   DEAD_BAND = 20;    
const unsigned long BUZZER_ALERT_MS = 10000; 
const unsigned long EMERGENCY_TRIGGER_MS = 15000; 

// --- State Machine ---
enum AppState {
  STATE_NORMAL,
  STATE_EMERGENCY_RAMP,
  STATE_HALTED
};
AppState currentState = STATE_NORMAL;

// --- Global Timers & States ---
int currentSpeed = 0;
unsigned long rampTimer = 0;
bool blinkingActive = false;
bool ledState = LOW;
unsigned long previousBlinkMillis = 0;
const long blinkInterval = 1000; 
bool smsSent = false;

// --- Steering Globals ---
int   last_for_movement = 0;
float ema = 0.0f;
unsigned long lastMoveMs = 0;
bool isBuzzerOn = false;


// ----------------------------------------------------------------
// HELPER: WiFi Connection Function (Reliable)
// ----------------------------------------------------------------
void setupWiFi() {
  Serial.print("Connecting to WiFi: ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
    attempts++;
    if (attempts > 40) { // 20-second timeout
      Serial.println("\nFailed to connect to WiFi. Restarting...");
      ESP.restart();
    }
  }
  Serial.println("\nWiFi Connected!");
  Serial.print("IP Address: ");
  Serial.println(WiFi.localIP());
}


// ----------------------------------------------------------------
// SETUP: Initialize all hardware
// ----------------------------------------------------------------
void setup() {
  // Start Serial Monitor
  Serial.begin(115200);
  delay(1000); // Wait for serial to connect

  // --- GPS Setup ---
  SerialGPS.begin(GPSBaud, SERIAL_8N1, RXPin, TXPin);
  Serial.println("GPS module initializing...");

  // --- Motor & LED & Buzzer Setup ---
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW); 
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT); 
  pinMode(ENA, OUTPUT);
  pinMode(buzzerPin, OUTPUT);
  digitalWrite(buzzerPin, LOW); 

  // --- Steering Pot Setup ---
  analogReadResolution(12);      
  analogSetPinAttenuation(potPin, ADC_11db); 
  
  // Initialize steering position
  int init = analogRead(potPin); 
  ema = init;
  last_for_movement = init;
  lastMoveMs = millis();

  // Start motor at full speed
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW); 
  analogWrite(ENA, MAX_DUTY);
  currentSpeed = MAX_DUTY;
  currentState = STATE_NORMAL;
  Serial.println("Motor starting. STATE: NORMAL");

  // --- Connect to WiFi ---
  setupWiFi(); 

  Serial.println("\nSystem Ready. Monitoring steering...");
}

// ----------------------------------------------------------------
// LOOP: Main non-blocking loop
// ----------------------------------------------------------------
void loop() {
  unsigned long currentMillis = millis();

  // --- Always run these functions ---
  feedGPS(); // Constantly read GPS data
  handleBlinking(currentMillis); // Handle LED state

  // Only run state logic if the system is not halted
  if (currentState != STATE_HALTED) {
    checkSteering(currentMillis);
    handleMotor(currentMillis);
  }
}

// ----------------------------------------------------------------
// HELPER FUNCTIONS
// ----------------------------------------------------------------

/**
 * @brief (From Steering) Reads 5 samples and returns the median
 */
int readMedian5(int pin) {
  int s[5];
  for (int i = 0; i < 5; i++) { s[i] = analogRead(pin); delayMicroseconds(300); }
  // sort small array
  for (int i = 0; i < 5; i++)
    for (int j = i + 1; j < 5; j++)
      if (s[j] < s[i]) { int t = s[i]; s[i] = s[j]; s[j] = t; }
  return s[2]; // median
}

/**
 * @brief Feeds data from GPS module to TinyGPS++ object.
 */
void feedGPS() {
  while (SerialGPS.available() > 0) {
    gps.encode(SerialGPS.read());
  }
}

/**
 * @brief Handles the indicator blink logic.
 */
void handleBlinking(unsigned long currentMillis) {
  if (blinkingActive) {
    if (currentMillis - previousBlinkMillis >= blinkInterval) {
      previousBlinkMillis = currentMillis;
      ledState = !ledState;
      digitalWrite(LED_PIN, ledState);
    }
  }
}

/**
 * @brief (NEW) Checks steering pot for movement and updates state.
 */
void checkSteering(unsigned long currentMillis) {
  // 1) Read + filter
  int   raw = readMedian5(potPin);
  ema = EMA_ALPHA * raw + (1.0f - EMA_ALPHA) * ema;
  int   smoothed = (int)(ema + 0.5f);

  // 2) Movement detection with deadband
  if (abs(smoothed - last_for_movement) > DEAD_BAND) {
    // --- MOVEMENT DETECTED! ---
    last_for_movement = smoothed;
    lastMoveMs = currentMillis;

    // Silence buzzer if it was on
    if (isBuzzerOn) {
      digitalWrite(buzzerPin, LOW);
      isBuzzerOn = false;
      Serial.println("Movement detected. Buzzer OFF.");
    }

    // If we were in an emergency ramp-down, CANCEL it.
    if (currentState == STATE_EMERGENCY_RAMP) {
      Serial.println("Movement detected! Cancelling emergency. Resuming normal operation.");
      currentState = STATE_NORMAL;
      blinkingActive = false;
      digitalWrite(LED_PIN, LOW);
      
      // Speed motor back up
      currentSpeed = MAX_DUTY;
      digitalWrite(IN1, HIGH); 
      digitalWrite(IN2, LOW);  
      analogWrite(ENA, currentSpeed);
    }
    return; 
  }

  // 3) --- NO MOVEMENT DETECTED ---
  // This code only runs if the 'if' block above is false.
  
  
  if (currentState == STATE_NORMAL) {
    unsigned long noMoveDuration = currentMillis - lastMoveMs;

    if (noMoveDuration > EMERGENCY_TRIGGER_MS) {
      // --- TRIGGER FULL EMERGENCY ---
      Serial.println("EMERGENCY: No steering for 15s. Halting vehicle.");
      currentState = STATE_EMERGENCY_RAMP;
      blinkingActive = true;
      rampTimer = currentMillis; // Start the motor ramp-down timer
      
      // Ensure buzzer is on
      if (!isBuzzerOn) {
        digitalWrite(buzzerPin, HIGH);
        isBuzzerOn = true;
      }

    } else if (noMoveDuration > BUZZER_ALERT_MS) {
      // --- TRIGGER BUZZER WARNING ONLY ---
      if (!isBuzzerOn) {
        Serial.println("Warning: No steering for 10s. Sounding buzzer.");
        digitalWrite(buzzerPin, HIGH);
        isBuzzerOn = true;
      }
    }
  }
}

void handleMotor(unsigned long currentMillis) {
  if (currentState == STATE_EMERGENCY_RAMP) {
    if (currentSpeed > 0) {
      
      if (currentMillis - rampTimer >= RAMP_DOWN_INTERVAL) {
        rampTimer = currentMillis;
        currentSpeed--;
        analogWrite(ENA, currentSpeed); 
      }
    }
    else {
     
      digitalWrite(IN1, LOW);
      digitalWrite(IN2, LOW);
      analogWrite(ENA, 0); 
      
      Serial.println("Motor ramp-down complete. Active brake applied. System HALTED.");
      printFinalLocation(); 
      
          triggerEmergencySMS();  
      
      currentState = STATE_HALTED; // This stops handleMotor/checkSteering from running again
    }
  }
}


void getISTDateTime(int& istYear, int& istMonth, int& istDay, int& istHour, int& istMinute) {
  // Get raw UTC data from GPS
  istYear = gps.date.year();
  istMonth = gps.date.month();
  istDay = gps.date.day();
  istHour = gps.time.hour();
  istMinute = gps.time.minute();

  
  istMinute += 30;
  istHour += 5;

  if (istMinute >= 60) {
    istMinute -= 60;
    istHour++;
  }
  if (istHour >= 24) {
    istHour -= 24;
    istDay++;
    int daysInMonth = 31;
    if (istMonth == 4 || istMonth == 6 || istMonth == 9 || istMonth == 11) { daysInMonth = 30; }
    else if (istMonth == 2) {
      if ((istYear % 4 == 0 && istYear % 100 != 0) || (istYear % 400 == 0)) { daysInMonth = 29; }
      else { daysInMonth = 28; }
    }
    if (istDay > daysInMonth) {
      istDay = 1; istMonth++;
      if (istMonth > 12) { istMonth = 1; istYear++; }
    }
  }
}


void triggerEmergencySMS() {
  if (smsSent) return; 
  smsSent = true;

  Serial.println("Building and sending minimal emergency SMS...");

  // Get raw GPS location
  String lat = gps.location.isValid() ? String(gps.location.lat(), 6) : "N/A";
  String lon = gps.location.isValid() ? String(gps.location.lng(), 6) : "N/A";

  // --- Get IST Date & Time ---
  int istYear = 0, istMonth = 0, istDay = 0, istHour = 0, istMinute = 0;
  char istDateStr[11] = "N/A";
  char istTimeStr[6] = "N/A"; // HH:MM
  if (gps.date.isValid() && gps.time.isValid()) {
    getISTDateTime(istYear, istMonth, istDay, istHour, istMinute);
    sprintf(istDateStr, "%04d-%02d-%02d", istYear, istMonth, istDay);
    sprintf(istTimeStr, "%02d:%02d", istHour, istMinute);
  }
  
  
  String messageBody = "EMERGENCY: Driver Unresponsive (Steering)\n";
  messageBody += "No steering movement detected.\n";
  messageBody += "Vehicle halting.\n";
  messageBody += "Time: " + String(istDateStr) + " " + String(istTimeStr) + " (IST)\n";
  messageBody += "Loc: " + lat + ", " + lon + "\n";
  messageBody += "Map: https://maps.google.com/maps?q=" + lat + "," + lon;

  Serial.println("--- Message Body ---");
  Serial.println(messageBody);
  Serial.println("--------------------");

  // Send the SMS
  sendSMS(messageBody);
}


String getGPSDate() {
  if (!gps.date.isValid()) return "N/A";
  String d = String(gps.date.year()) + "-";
  if (gps.date.month() < 10) d += "0";
  d += String(gps.date.month()) + "-";
  if (gps.date.day() < 10) d += "0";
  d += String(gps.date.day());
  return d;
}


String getGPSTime() {
  if (!gps.time.isValid()) return "N/A";
  String t = "";
  if (gps.time.hour() < 10) t += "0";
  t += String(gps.time.hour()) + ":";
  if (gps.time.minute() < 10) t += "0";
  t += String(gps.time.minute()) + ":";
  if (gps.time.second() < 10) t += "0";
  t += String(gps.time.second());
  return t;
}


void printFinalLocation() {
  Serial.println("\n===== FINAL EMERGENCY LOCATION =====");
  Serial.print("Latitude: ");
  Serial.println(gps.location.isValid() ? String(gps.location.lat(), 6) : "NO FIX");
  Serial.print("Longitude: ");
  Serial.println(gps.location.isValid() ? String(gps.location.lng(), 6) : "NO FIX");
  Serial.print("Date (UTC): ");
  Serial.println(getGPSDate());
  Serial.print("Time (UTC): ");
  Serial.println(getGPSTime());
  Serial.println("==================================\n");
}



void sendSMS(String messageBody) {
  // Check WiFi connection
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi disconnected. Attempting to reconnect for SMS...");
    WiFi.reconnect();
    int attempts = 0;
    while (WiFi.status() != WL_CONNECTED) {
      delay(500);
      Serial.print(".");
      if (attempts++ > 20) {
        Serial.println("\nReconnect failed. SMS will not be sent.");
        return;
      }
    }
    Serial.println("\nWi-Fi reconnected for SMS.");
  }

  WiFiClientSecure client;
  

  Serial.println("WARNING: Bypassing SSL certificate validation.");
  client.setInsecure(); 

  Serial.print("Connecting to Twilio (insecurely): ");
  Serial.println(host);

  if (!client.connect(host, httpsPort)) {
    Serial.println("Connection failed!");
    Serial.println("Even with setInsecure(), this can fail due to:");
    Serial.println("1. No internet route to api.twilio.com");
    Serial.lntln("2. Local WiFi firewall blocking port 443");
    return;
  }
  Serial.println("Connected to Twilio.");

  String url = "/2010-04-01/Accounts/" + String(accountSID) + "/Messages.json";
  String credentials = String(accountSID) + ":" + String(authToken);
  String encoded = base64::encode(credentials);
  String authHeader = "Authorization: Basic " + encoded;

  String postData = "To=" + urlEncode(toNumber) +
                    "&From=" + urlEncode(fromNumber) +
                    "&Body=" + urlEncode(messageBody);

  client.println("POST " + url + " HTTP/1.1");
  client.println("Host: "L + String(host));
  client.println("User-Agent: ESP32-Emergency-Bot");
  client.println("Connection: close");
  client.println("Content-Type: application/x-www-form-urlencoded");
  client.println(authHeader);
  client.print("Content-Length: ");
  client.println(postData.length());
  client.println();
  client.print(postData);

  Serial.println("POST request sent.");

  // Wait for and print the response
  unsigned long timeout = millis();
  while (client.connected() && millis() - timeout < 5000) { // 5 sec timeout
    if (client.available()) {
      String line = client.readStringUntil('\n');
      Serial.println(line);
      if (line == "\r") {
        break; // End of headers
      }
    }
  }

  // Read the body
  Serial.println("--- Twilio Response Body ---");
  while (client.available()) {
    char c = client.read();
    Serial.print(c);
  }
  Serial.println("\n----------------------------");
  client.stop();
}



String urlEncode(String str) {
  String encodedString = "";
  char c;
  char code0;
  char code1;
  for (int i = 0; i < str.length(); i++) {
    c = str.charAt(i);
    if (c == ' ') {
      encodedString += '+';
    } else if (isalnum(c)) {
      encodedString += c;
    } else {
      code1 = (c & 0xf) + '0';
      if ((c & 0xf) > 9) { code1 = (c & 0xf) - 10 + 'A'; }
      c = (c >> 4) & 0xf;
      code0 = c + '0';
      if (c > 9) { code0 = c - 10 + 'A'; }
      encodedString += '%';
      encodedString += code0;
      encodedString += code1;
    }
  }
  return encodedString;
}