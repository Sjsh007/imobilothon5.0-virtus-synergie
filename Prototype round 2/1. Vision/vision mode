import cv2
import mediapipe as mp
import time
import math
from collections import deque
from picamera2 import Picamera2
import subprocess  # For playing sound

# ----------------- SOUND FILE PATHS -----------------
SOUND_BREAK = "/home/volkswagon/Downloads/audio/break.mp3"
SOUND_FOCUS = "/home/volkswagon/Downloads/audio/focus.mp3"

# ----------------- SOUND PLAYBACK FUNCTION -----------------
def play_sound(sound_file):
    """Plays a sound file non-blockingly using mpg123."""
    try:
        subprocess.Popen(["mpg123", "-q", sound_file])
        print(f"ðŸ”Š Playing: {sound_file.split('/')[-1]}")
    except FileNotFoundError:
        print("âš  ERROR: 'mpg123' not found. Please install it: sudo apt install mpg123")
    except Exception as e:
        print(f"âš  Error playing sound: {e}")

def alert_fatigue():
    """Alert for fatigue events (microsleep, yawn, perclos)."""
    print(" FATIGUE ALERT â†’ Playing break.mp3")
    play_sound(SOUND_BREAK)

def alert_distraction():
    """Alert for distraction events (look away)."""
    print(" DISTRACTION ALERT â†’ Playing focus.mp3")
    play_sound(SOUND_FOCUS)

# ----------------- MEDIAPIPE SETUP -----------------
mp_face_mesh = mp.solutions.face_mesh
face_mesh = mp_face_mesh.FaceMesh(
    max_num_faces=1,
    refine_landmarks=True,
    min_detection_confidence=0.6,
    min_tracking_confidence=0.6
)


print("ðŸŽ¥ Initializing Camera...")
picam2 = Picamera2()
config = picam2.create_preview_configuration(main={"format": "BGR888", "size": (640, 480)})
picam2.configure(config)
picam2.start()
print(" Camera Ready")

LEFT_EYE  = [33, 160, 158, 133, 153, 144]
RIGHT_EYE = [362, 385, 387, 263, 373, 380]
MOUTH = [13, 14, 78, 308]
NOSE_TIP = 1


CALIB_SECONDS = 3.0      
EYE_CLOSED_TIME = 3.0     

MAR_HIGH = 0.72           
MAR_LOW  = 0.55           
MIN_YAWN_DURATION = 0.6   
YAWN_WINDOW = 60          
YAWN_TRIGGER = 3          

HEAD_TURN_THRESHOLD = 0.14
HEAD_TURN_TIME = 1.2


PERCLOS_START_DELAY = 20.0    
PERCLOS_THRESHOLD = 0.30      
PERCLOS_ALERT_COOLDOWN = 15.0 


ear_samples = []
calib_start = time.time()
ear_open_mean = None
ear_closed_th = None
ear_reopen_th = None

eye_closed_start = None
eyes_closed_latch = False

yawn_active = False
yawn_open_start = None
yawn_times = deque()

head_turn_start = None


perclos_total_samples = 0
perclos_closed_samples = 0
perclos_start_time = None
last_perclos_alert_time = 0


eye_status = "---"

def dist(p1, p2):
    return math.hypot(p1.x - p2.x, p1.y - p2.y)

def ear(lm, e):
    return (dist(lm[e[1]], lm[e[5]]) + dist(lm[e[2]], lm.landmark[e[4]])) / (2 * dist(lm[e[0]], lm[e[3]]))

def mar(lm):
    return dist(lm[MOUTH[0]], lm[MOUTH[1]]) / dist(lm[MOUTH[2]], lm[MOUTH[3]])


while True:
    frame = picam2.capture_array()
    frame = cv2.flip(frame, 1)
    rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    result = face_mesh.process(rgb)

    if result.multi_face_landmarks:
        lm = result.multi_face_landmarks[0].landmark
        
        ear_val = (ear(lm, LEFT_EYE) + ear(lm, RIGHT_EYE)) / 2
        mar_val = mar(lm)
        nose_x = lm[NOSE_TIP].x

        
        if ear_open_mean is None:
            if time.time() - calib_start <= CALIB_SECONDS:
                if ear_val > 0:
                    ear_samples.append(ear_val)
               
                cv2.putText(frame, "Calibrating... Keep eyes OPEN", (10,30),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,255,255), 2)
            else:
                if not ear_samples:
                    print("Calibration failed, no eye data. Retrying...")
                    calib_start = time.time()
                else:
                    ear_open_mean = sum(ear_samples)/len(ear_samples)
                    ear_closed_th = ear_open_mean * 0.65
                    ear_reopen_th = ear_open_mean * 0.82
                    print(f"ðŸ”§ EAR calibrated: open={ear_open_mean:.3f}, closed={ear_closed_th:.3f}, reopen={ear_reopen_th:.3f}")
                    
                    perclos_start_time = time.time()
                    print(f" PERCLOS calculation will display after {PERCLOS_START_DELAY} seconds.")

       
        else:  
            
            
            if ear_val < ear_closed_th:
                eye_status = "CLOSED"
            else:
                eye_status = "OPEN"

           
            if not eyes_closed_latch:
                if eye_status == "CLOSED":
                    if eye_closed_start is None:
                        eye_closed_start = time.time()
                    elif time.time() - eye_closed_start > EYE_CLOSED_TIME:
                        eyes_closed_latch = True
                        eye_closed_start = None 
                        
                        
                        alert_fatigue() 
                        
                else:
                    eye_closed_start = None
            else:
                if ear_val > ear_reopen_th:
                    eyes_closed_latch = False

            
            current_time = time.time()
            
            # Always gather data
            is_closed_frame = 1 if eye_status == "CLOSED" else 0
            perclos_total_samples += 1
            perclos_closed_samples += is_closed_frame
            
            # Calculate and display PERCLOS
            perclos_val = 0.0
            perclos_display = "Warming up..."
            
            if current_time - perclos_start_time > PERCLOS_START_DELAY:
                if perclos_total_samples > 0:
                    perclos_val = perclos_closed_samples / perclos_total_samples
                    perclos_display = f"{perclos_val*100:.0f}%"
                
               
                if perclos_val > PERCLOS_THRESHOLD and current_time - last_perclos_alert_time > PERCLOS_ALERT_COOLDOWN:
                    
                  
                    alert_fatigue() 
                    
                    last_perclos_alert_time = current_time
            
           
            cv2.putText(frame, f"S:{eye_status} P:{perclos_display} E:{ear_val:.2f}", (10,30),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255,255,255), 2)

        # -------- YAWN DETECTION (Always active) --------
        if not yawn_active and mar_val > MAR_HIGH:
            yawn_active = True
            yawn_open_start = time.time()

        if yawn_active and mar_val < MAR_LOW:
            yawn_active = False
            if time.time() - yawn_open_start >= MIN_YAWN_DURATION:
                yawn_times.append(time.time())
                print(f" Yawn detected. (Count: {len(yawn_times)})")

        # Prune old yawns
        while yawn_times and time.time() - yawn_times[0] > YAWN_WINDOW:
            yawn_times.popleft()

        # Alert on yawn threshold
        if len(yawn_times) >= YAWN_TRIGGER:
            
            # (perclos, microsleep, yawn: break.mp3)
            alert_fatigue() 
            
            yawn_times.clear()

        # -------- HEAD TURN (Always active) --------
        if abs(nose_x - 0.5) > HEAD_TURN_THRESHOLD:
            if head_turn_start is None:
                head_turn_start = time.time()
            elif time.time() - head_turn_start > HEAD_TURN_TIME:
                
                # (look away: focus.mp3)
                alert_distraction() 
                
                head_turn_start = None
        else:
            head_turn_start = None

    else:
        # No face detected
        eye_status = "---"
        cv2.putText(frame, "No Face Detected", (10, 30),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)

    cv2.imshow("Driver Monitoring System", frame)
    if cv2.waitKey(1) & 0xFF == 27:
        break

cv2.destroyAllWindows()
picam2.stop()
face_mesh.close()
print(" System Stopped")