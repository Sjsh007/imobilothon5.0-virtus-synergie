// =================================================================
// === COMBINED DRIVER WELLNESS & EMERGENCY RESPONSE SYSTEM ===
// =================================================================
// --- v3 (Fixed Twilio SSL/Time Sync) ---

// --- WiFi & HTTP Libraries ---
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <base64.h> // correct for Densaugeo library

// --- GPS Libraries ---
#include <TinyGPSPlus.h>
#include <HardwareSerial.h>

// --- (NEW) Time Libraries for SSL Fix ---
#include <time.h>
#include <sys/time.h>

// --- WiFi Credentials ---
const char* ssid = "Kibo_AirFiber";
const char* password = "kibo@123";

// --- Twilio API Credentials ---
const char* accountSID = "AC8a4a960da915ea5983a02c547633ada3";
const char* authToken  = "729f9db8e5fe0099b056f87cc7846494";
const char* fromNumber = "+18025230859";
const char* toNumber   = "+919880662453";
const char* host = "api.twilio.com";
const int httpsPort = 443;

// --- Hardware Pins ---
const int ENA = 25;      // L298N ENA (PWM)
const int IN1 = 26;      // L298N IN1
const int IN2 = 27;      // L298N IN2 (*** ADDED FOR ACTIVE BRAKING ***)
#define LED_PIN 4        // External LED on GPIO4 (D4)

// --- GPS Settings ---
static const int RXPin = 16; // GPS TX -> ESP32 RX2
static const int TXPin = 17; // GPS RX -> ESP32 TX2
static const uint32_t GPSBaud = 9600;

// --- GPS Objects ---
TinyGPSPlus gps;
HardwareSerial SerialGPS(2); // UART2 on ESP32

// --- Motor Settings ---
const uint8_t MAX_DUTY = 160;
const unsigned long RAMP_DOWN_TIME = 10000;
const unsigned long RAMP_DOWN_INTERVAL = RAMP_DOWN_TIME / MAX_DUTY;

// --- State Machine ---
enum AppState {
  STATE_NORMAL,
  STATE_EMERGENCY_RAMP,
  STATE_HALTED
};
AppState currentState = STATE_NORMAL;

// --- Global Timers & States ---
int currentSpeed = 0;
unsigned long rampTimer = 0;
bool blinkingActive = false;
bool ledState = LOW;
unsigned long previousBlinkMillis = 0;
const long blinkInterval = 1000; // 1 second

// --- Global Emergency Data ---
String emergencyHR = "N/A";
String emergencySpO2 = "N/A";
bool smsSent = false;


// ----------------------------------------------------------------
// HELPER: WiFi Connection Function (Reliable)
// ----------------------------------------------------------------
void setupWiFi() {
  Serial.print("Connecting to WiFi: ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
    attempts++;
    if (attempts > 40) { // 20-second timeout
      Serial.println("\nFailed to connect to WiFi. Restarting...");
      ESP.restart();
    }
  }
  Serial.println("\nWiFi Connected!");
  Serial.print("IP Address: ");
  Serial.println(WiFi.localIP());
}

/**
 * @brief (MOVED UP) Feeds data from GPS module to TinyGPS++ object.
 */
void feedGPS() {
  while (SerialGPS.available() > 0) {
    gps.encode(SerialGPS.read());
  }
}

/**
 * @brief (<<< NEWLY ADDED FUNCTION)
 * Waits for a valid GPS fix and syncs the ESP32 system clock.
 * This is CRITICAL for SSL/TLS connections (like to Twilio) to work.
 */
void syncClockToGPS() {
  unsigned long start = millis();
  bool gpsTimeSet = false;

  Serial.print("Waiting for GPS fix to sync time");
  
  while (!gpsTimeSet && millis() - start < 30000) { // 30-second timeout
    feedGPS(); // Keep feeding GPS data

    if (gps.date.isValid() && gps.time.isValid()) {
      struct tm tm;
      tm.tm_year = gps.date.year() - 1900;
      tm.tm_mon = gps.date.month() - 1; // 0-11
      tm.tm_mday = gps.date.day();
      tm.tm_hour = gps.time.hour();
      tm.tm_min = gps.time.minute();
      tm.tm_sec = gps.time.second();

      time_t epochTime = mktime(&tm); // Convert tm to seconds since epoch

      struct timeval tv;
      tv.tv_sec = epochTime;
      tv.tv_usec = 0;
      settimeofday(&tv, NULL); // Set the system time

      Serial.println("\nSuccessfully synced system clock to GPS (UTC).");
      
      // Print the new system time to confirm
      char timeStr[64];
      strftime(timeStr, sizeof(timeStr), "%c", &tm);
      Serial.print("System Time Set To: ");
      Serial.println(timeStr);

      gpsTimeSet = true;
    } else {
      Serial.print(".");
      delay(500);
    }
  }

  if (!gpsTimeSet) {
    Serial.println("\nWarning: Failed to get GPS time sync. SSL connection may fail.");
    Serial.println("Continuing without time sync...");
  }
}


// ----------------------------------------------------------------
// SETUP: Initialize all hardware
// ----------------------------------------------------------------
void setup() {
  // Start Serial Monitor
  Serial.begin(115200);
  delay(1000); // Wait for serial to connect

  // --- GPS Setup ---
  SerialGPS.begin(GPSBaud, SERIAL_8N1, RXPin, TXPin);
  Serial.println("GPS module initializing...");

  // --- Motor & LED Setup ---
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW); // LED is OFF
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT); // *** ADDED ***
  pinMode(ENA, OUTPUT);

  // Start motor at full speed
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW); // *** ADDED: Set forward direction ***
  analogWrite(ENA, MAX_DUTY);
  currentSpeed = MAX_DUTY;
  currentState = STATE_NORMAL;
  Serial.println("Motor starting. STATE: NORMAL");

  // --- FIXED: WiFi Setup (Reliable & Blocking) ---
  setupWiFi(); // This now waits for a connection

  // --- (<<< NEWLY ADDED) Sync system clock to GPS for SSL ---
  syncClockToGPS(); // This is critical for Twilio HTTPS

  Serial.println("\nSystem Ready. Waiting for emergency signal from Python...");
  Serial.println("Format: E,HR,SPO2\\n (e.g., E,145,87)");
}

// ----------------------------------------------------------------
// LOOP: Main non-blocking loop
// ----------------------------------------------------------------
void loop() {
  unsigned long currentMillis = millis();

  // --- Always run these functions ---
  feedGPS(); // Constantly read GPS data
  handleBlinking(currentMillis); // Handle LED state

  // Only run motor/serial logic if the system is not halted
  if (currentState != STATE_HALTED) {
    checkSerial();
    handleMotor(currentMillis);
  }
}

// ----------------------------------------------------------------
// HELPER FUNCTIONS
// ----------------------------------------------------------------


/**
 * @brief Handles the indicator blink logic.
 */
void handleBlinking(unsigned long currentMillis) {
  if (blinkingActive) {
    if (currentMillis - previousBlinkMillis >= blinkInterval) {
      previousBlinkMillis = currentMillis;
      ledState = !ledState;
      digitalWrite(LED_PIN, ledState);
    }
  }
}

/**
 * @brief Checks for 'E' command from Python and parses data.
 */
void checkSerial() {
  if (Serial.available()) {
    // Read the incoming command: "E,HR,SPO2\n"
    String serialData = Serial.readStringUntil('\n');
    serialData.trim();

    if (serialData.startsWith("E")) {
      if (currentState == STATE_NORMAL) {
        Serial.print("EMERGENCY received! Data: ");
        Serial.println(serialData);
        Serial.println("Slowing down. LED BLINKING.");

        // Parse the HR and SpO2 values
        int firstComma = serialData.indexOf(',');
        int secondComma = serialData.indexOf(',', firstComma + 1);

        if (firstComma > 0 && secondComma > 0) {
          emergencyHR = serialData.substring(firstComma + 1, secondComma);
          emergencySpO2 = serialData.substring(secondComma + 1);
        }

        currentState = STATE_EMERGENCY_RAMP;
        blinkingActive = true; // This starts the blinker
        rampTimer = millis();
      }
    } else if (serialData.startsWith("N")) {
      // Received "Normal" signal, do nothing
    }
  }
}

/**
 * @brief Handles the motor ramp-down and active braking.
 * (*** MODIFIED ***)
 */
void handleMotor(unsigned long currentMillis) {
  if (currentState == STATE_EMERGENCY_RAMP) {
    if (currentSpeed > 0) {
      // Still ramping down
      if (currentMillis - rampTimer >= RAMP_DOWN_INTERVAL) {
        rampTimer = currentMillis;
        currentSpeed--;
        analogWrite(ENA, currentSpeed); // This ramps down the speed
      }
    }
    else {
      // Motor speed has reached 0.
      // APPLY ACTIVE BRAKE (IN1=LOW, IN2=LOW)
      digitalWrite(IN1, LOW);
      digitalWrite(IN2, LOW);
      analogWrite(ENA, 0); // Ensure ENA is off
      
      Serial.println("Motor ramp-down complete. Active brake applied. System HALTED.");
      printFinalLocation(); // Log to serial
      
      // --- TRIGGER THE SMS SEND ---
      triggerEmergencySMS();  
      
      currentState = STATE_HALTED; // This stops handleMotor/checkSerial from running again
    }
  }
}

/**
 * @brief (NEW) Helper function to calculate IST from GPS UTC time.
 * Populates the referenced variables with IST date/time.
 */
void getISTDateTime(int& istYear, int& istMonth, int& istDay, int& istHour, int& istMinute) {
  // Get raw UTC data from GPS
  istYear = gps.date.year();
  istMonth = gps.date.month();
  istDay = gps.date.day();
  istHour = gps.time.hour();
  istMinute = gps.time.minute();

  // Apply +5:30 offset for IST
  istMinute += 30;
  istHour += 5;

  // Handle rollovers
  if (istMinute >= 60) {
    istMinute -= 60;
    istHour++;
  }
  
  if (istHour >= 24) {
    istHour -= 24;
    istDay++;
    
    // Simple check for end of month
    int daysInMonth = 31; // Default
    if (istMonth == 4 || istMonth == 6 || istMonth == 9 || istMonth == 11) {
      daysInMonth = 30;
    } else if (istMonth == 2) {
      // Check for leap year
      if ((istYear % 4 == 0 && istYear % 100 != 0) || (istYear % 400 == 0)) {
        daysInMonth = 29;
      } else {
        daysInMonth = 28;
      }
    }
    
    // Check for day rollover
    if (istDay > daysInMonth) {
      istDay = 1;
      istMonth++;
      if (istMonth > 12) {
        istMonth = 1;
        istYear++;
      }
    }
  }
}

/**
 * @brief (MODIFIED) Gatekeeper function to send a minimal SMS.
 */
void triggerEmergencySMS() {
  if (smsSent) return; // Don't send more than one
  smsSent = true;

  Serial.println("Building and sending minimal emergency SMS...");

  // Get raw GPS location
  String lat = gps.location.isValid() ? String(gps.location.lat(), 6) : "N/A";
  String lon = gps.location.isValid() ? String(gps.location.lng(), 6) : "N/A";

  // --- NEW: Get IST Date & Time ---
  int istYear = 0, istMonth = 0, istDay = 0, istHour = 0, istMinute = 0;
  char istDateStr[11] = "N/A";
  char istTimeStr[6] = "N/A"; // HH:MM

  if (gps.date.isValid() && gps.time.isValid()) {
    getISTDateTime(istYear, istMonth, istDay, istHour, istMinute);
    sprintf(istDateStr, "%04d-%02d-%02d", istYear, istMonth, istDay);
    sprintf(istTimeStr, "%02d:%02d", istHour, istMinute);
  }
  
  // --- NEW: Build the minimal message body ---
  String messageBody = "EMERGENCY: Driver Unresponsive\n";
  messageBody += "HR: " + emergencyHR + " bpm\n";
  messageBody += "SpO2: " + emergencySpO2 + "%\n";
  messageBody += "Time: " + String(istDateStr) + " " + String(istTimeStr) + " (IST)\n";
  messageBody += "Loc: " + lat + ", " + lon + "\n";
  messageBody += "Map: http://maps.google.com/maps?q=" + lat + "," + lon;

  Serial.println("--- Message Body ---");
  Serial.println(messageBody);
  Serial.println("--------------------");

  // Send the SMS
  sendSMS(messageBody);
}

// --- FUNCTIONS ADDED BACK IN ---

/**
 * @brief Helper function to get 0-padded date string (for Serial Monitor).
 */
String getGPSDate() {
  if (!gps.date.isValid()) return "N/A";
  String d = String(gps.date.year()) + "-";
  if (gps.date.month() < 10) d += "0";
  d += String(gps.date.month()) + "-";
  if (gps.date.day() < 10) d += "0";
  d += String(gps.date.day());
  return d;
}

/**
 * @brief Helper function to get 0-padded time string (for Serial Monitor).
 */
String getGPSTime() {
  if (!gps.time.isValid()) return "N/A";
  String t = "";
  if (gps.time.hour() < 10) t += "0";
  t += String(gps.time.hour()) + ":";
  if (gps.time.minute() < 10) t += "0";
  t += String(gps.time.minute()) + ":";
  if (gps.time.second() < 10) t += "0";
  t += String(gps.time.second());
  return t;
}

// --- END OF FUNCTIONS ADDED BACK IN ---


/**
 * @brief Prints the final GPS location to Serial Monitor.
 */
void printFinalLocation() {
  Serial.println("\n===== FINAL EMERGENCY LOCATION =====");
  Serial.print("Latitude: ");
  Serial.println(gps.location.isValid() ? String(gps.location.lat(), 6) : "NO FIX");
  Serial.print("Longitude: ");
  Serial.println(gps.location.isValid() ? String(gps.location.lng(), 6) : "NO FIX");
  Serial.print("Date (UTC): ");
  Serial.println(getGPSDate()); // This will now work
  Serial.print("Time (UTC): ");
  Serial.println(getGPSTime()); // This will now work
  Serial.println("==================================\n");
}


/**
 * @brief (FIXED) Connects to Twilio and sends the SMS.
 */
void sendSMS(String messageBody) {
  // Check WiFi connection
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi disconnected. Attempting to reconnect for SMS...");
    WiFi.reconnect(); // Use reconnect, not begin

    int attempts = 0;
    while (WiFi.status() != WL_CONNECTED) {
      delay(500);
      Serial.print(".");
      if (attempts++ > 20) { // 10s timeout
         Serial.println("\nReconnect failed. SMS may not send.");
         return; // Exit the function
      }
    }
    Serial.println("\nWi-Fi reconnected for SMS.");
  }

  WiFiClientSecure client;
  client.setInsecure(); // skip certificate verification

  Serial.print("Connecting to Twilio: ");
  Serial.println(host);

  // (<<< THIS IS THE LINE THAT WAS FAILING)
  if (!client.connect(host, httpsPort)) {
    Serial.println("Connection failed! (This is the error you were seeing)");
    Serial.println("Check system time sync, WiFi, and host name.");
    return;
  }
  Serial.println("Connected to Twilio."); // <<< You should see this now!

  String url = "/2010-04-01/Accounts/" + String(accountSID) + "/Messages.json";

  // Encode Account SID + Auth Token into Base64
  String credentials = String(accountSID) + ":" + String(authToken);
  String encoded = base64::encode(credentials);
  String authHeader = "Authorization: Basic " + encoded;

  // --- CRITICAL FIX: URL Encode all parts of the POST data ---
  String postData = "To=" + urlEncode(toNumber) +
                    "&From=" + urlEncode(fromNumber) +
                    "&Body=" + urlEncode(messageBody);

  // Send POST request
  client.println("POST " + url + " HTTP/1.1");
  client.println("Host: " + String(host));
  client.println("User-Agent: ESP32-Emergency-Bot");
  client.println("Content-Type: application/x-www-form-urlencoded");
  client.println(authHeader);
  client.print("Content-Length: ");
  client.println(postData.length());
  client.println();
  client.print(postData);

  Serial.println("POST request sent.");

  // Read server response
  while (client.connected()) {
    String line = client.readStringUntil('\n');
    if (line == "\r") break;
  }

  String response = client.readString();
  Serial.println("--- Twilio Response ---");
  Serial.println(response);
  Serial.println("-----------------------");
  
  client.stop(); // Stop the client
}


// --- URL Encoding Function ---
// (Required for Twilio API)
String urlEncode(String str) {
  String encodedString = "";
  char c;
  char code0;
  char code1;
  for (int i = 0; i < str.length(); i++) {
    c = str.charAt(i);
    if (c == ' ') {
      encodedString += '+';
    } else if (isalnum(c)) {
      encodedString += c;
    } else {
      code1 = (c & 0xf) + '0';
      if ((c & 0xf) > 9) {
        code1 = (c & 0xf) - 10 + 'A';
      }
      c = (c >> 4) & 0xf;
      code0 = c + '0';
      if (c > 9) {
        code0 = c - 10 + 'A';
      }
      encodedString += '%';
      encodedString += code0;
      encodedString += code1;
    }
  }
  return encodedString;
}