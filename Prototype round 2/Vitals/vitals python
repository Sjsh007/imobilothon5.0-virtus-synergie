import tkinter as tk
from tkinter import ttk
import time
import math
import sys
import requests
import serial
from PIL import Image, ImageDraw, ImageFilter, ImageTk

# --- SET YOUR SERIAL PORT HERE ---
ser = None # Initialize as None. We will connect *after* the GUI starts.

# --- UPDATED: Add a global buffer for serial data ---
serial_buffer = b""

try:
    import winsound
    _HAS_WINSOUND = True
except Exception:
    _HAS_WINSOUND = False

# --- MSG91 SMS integration (Kept in code, but no longer used in emergency logic) ---
def send_sms_alert(to_number, message):
    url = "https://api.msg91.com/api/v2/sendsms"
    headers = {
        "authkey": "476887AUHum5IZOcm690dd92cP1",
        "content-type": "application/json"
    }
    payload = {
        "sender": "msg91",
        "route": "4",
        "country": "91",
        "sms": [
            {
                "message": message,
                "to": [7624904991]
            }
        ]
    }
    try:
        response = requests.post(url, json=payload, headers=headers)
        print("SMS sent:", response.text)
    except Exception as e:
        print("SMS sending error:", e)

# --- Thresholds Based on Driving Safety Guidelines ---
HR_SAFE_MIN = 60
HR_SAFE_MAX = 100
HR_MILD_LOW_MIN = 50
HR_MILD_HIGH_MAX = 120
HR_STOP_LOW_MIN = 40
HR_STOP_HIGH_MAX = 140

SPO2_SAFE_MIN = 95
SPO2_MILD_MIN = 92
SPO2_STOP_MIN = 88

pulse_phase = 0.0
running = True
last_alert = None
last_spo2_alert = None
bg_photo = None

CANVAS_SIZE = 600
CENTER = CANVAS_SIZE // 2

def play_beep(alert_level="mild"):
    if _HAS_WINSOUND:
        if alert_level == "emergency":
            for _ in range(3):
                winsound.Beep(2000, 150)
        elif alert_level == "stop":
            winsound.Beep(1500, 200)
            time.sleep(0.05)
            winsound.Beep(1500, 200)
        else:
            winsound.Beep(1000, 250)
    else:
        root.bell()

def create_watch_background(size=CANVAS_SIZE):
    img = Image.new("RGBA", (size, size), (0, 0, 0, 0))
    draw = ImageDraw.Draw(img)
    padding = 20
    x1, y1 = padding, padding
    x2, y2 = size - padding, size - padding
    shadow = Image.new("RGBA", (size, size), (0, 0, 0, 0))
    sd = ImageDraw.Draw(shadow)
    sd.rectangle((x1 + 8, y1 + 8, x2 + 8, y2 + 8), fill=(0, 0, 0, 140))
    shadow = shadow.filter(ImageFilter.GaussianBlur(20))
    img.alpha_composite(shadow)
    for i in range(15, 0, -1):
        brightness = int(80 - (i * 3))
        color = (brightness, brightness, brightness, 255)
        draw.rectangle((x1 - i, y1 - i, x2 + i, y2 + i), outline=color, width=1)
    draw.rectangle((x1, y1, x2, y2), outline=(200, 200, 200, 255), width=4)
    glass = Image.new("RGBA", (size, size), (18, 22, 28, 255))
    img.alpha_composite(glass)
    return ImageTk.PhotoImage(img)

def get_hr_status(hr):
    if HR_SAFE_MIN <= hr <= HR_SAFE_MAX:
        return "safe", "#7CFC00", "Safe to drive"
    elif (HR_MILD_LOW_MIN <= hr < HR_SAFE_MIN) or (HR_SAFE_MAX < hr <= HR_MILD_HIGH_MAX):
        return "mild", "#FFD700", "Mild caution"
    elif (HR_STOP_LOW_MIN <= hr < HR_MILD_LOW_MIN) or (HR_MILD_HIGH_MAX < hr <= HR_STOP_HIGH_MAX):
        return "stop", "#FF8C00", "Stop driving"
    else:
        return "emergency", "#FF0000", "EMERGENCY"

def get_spo2_status(spo2):
    if spo2 >= SPO2_SAFE_MIN:
        return "safe", "#7CFC00", "Normal"
    elif SPO2_MILD_MIN <= spo2 < SPO2_SAFE_MIN:
        return "mild", "#FFD700", "Caution"
    elif SPO2_STOP_MIN <= spo2 < SPO2_MILD_MIN:
        return "stop", "#FF8C00", "Alert"
    else:
        return "emergency", "#FF0000", "EMERGENCY"

def connect_to_esp32():
    """Tries to connect to the serial port after the GUI has started."""
    global ser 
    if ser is None:
        try:
            # Connect with both read and write timeouts
            ser = serial.Serial(
                "/dev/ttyUSB0", 
                115200, 
                timeout=0.1,      # Read timeout
                write_timeout=1.0   # Write timeout
            ) 
            print("Successfully connected to serial port /dev/ttyUSB0")
        except Exception as e:
            print(f"ERROR: Could not open serial port. {e}")
            print("Running in simulation mode without serial connection.")
            ser = None

def process_serial_data():
    """
    Read all available data from serial, add to buffer,
    and process any complete lines.
    This is non-blocking and safe to call in a GUI loop.
    """
    global serial_buffer
    
    # 1. Read all available data (non-blocking)
    if ser and ser.in_waiting > 0:
        try:
            # Read *only* what's waiting in the buffer
            new_data = ser.read(ser.in_waiting)
            serial_buffer += new_data
        except Exception as e:
            print(f"Serial read error: {e}")
            return # Stop processing on error

    # 2. Process all complete lines in the buffer
    # We use 'while' in case multiple lines (e.g., "OK\nOK\n") arrived
    while b'\n' in serial_buffer:
        try:
            # Split off the first complete line
            line, serial_buffer = serial_buffer.split(b'\n', 1)
            response = line.decode('utf-8').strip()
            
            if response:
                print(f"ESP32 says: --> {response}")
                
        except UnicodeDecodeError:
            print(f"Serial decode error. Discarding buffer: {serial_buffer}")
            serial_buffer = b"" # Clear buffer on error
        except Exception as e:
            print(f"Error processing serial line: {e}")


def update_status(event=None):
    # --- THIS IS THE FIX ---
    global last_alert, last_spo2_alert, ser
    # -----------------------
    
    hr = hr_var.get()
    spo2 = spo2_var.get()

    hr_level, hr_color, hr_msg = get_hr_status(hr)
    spo2_level, spo2_color, spo2_msg = get_spo2_status(spo2)

    hud_text = f"HR: {hr} bpm\nSpO2: {spo2}%"
    canvas.itemconfig(digital_text_id, text=hud_text)

    status_priority = {"emergency": 4, "stop": 3, "mild": 2, "safe": 1}

    if status_priority[hr_level] >= status_priority[spo2_level]:
        overall_level, overall_color, status_msg = hr_level, hr_color, hr_msg
    else:
        overall_level, overall_color, status_msg = spo2_level, spo2_color, spo2_msg

    canvas.itemconfig(digital_text_id, fill=overall_color)
    canvas.itemconfig(status_msg_id, text=status_msg, fill=overall_color)
    canvas.itemconfig(rect_bg_id, outline=overall_color)
    canvas.itemconfig(hr_label, text=f"HR: {hr} bpm")
    canvas.itemconfig(spo2_label, text=f"SpO2: {spo2}%")

    emergency_condition = (spo2 < SPO2_STOP_MIN or hr < HR_STOP_LOW_MIN or hr > HR_STOP_HIGH_MAX)

    if ser: # Only try to write if serial connection exists
        try:
            if emergency_condition:
                serial_message = f"E,{hr},{spo2}\n"
                ser.write(serial_message.encode('utf-8')) 
                
                if last_alert != "emergency":
                    print(f"Sending EMERGENCY signal to ESP32: {serial_message.strip()}")
                    play_beep("emergency")
                    last_alert = "emergency"
            else:
                ser.write(b'N\n') 
                if last_alert != overall_level and last_alert == "emergency":
                     print("Sending NORMAL signal to ESP32: N")
                last_alert = overall_level
        except serial.SerialTimeoutException:
            print("Serial write timed out. ESP32 might not be ready.")
        except Exception as e:
            print(f"Serial write error: {e}")
            # Disconnect on write error
            ser.close()
            ser = None
            print("Serial connection lost.")

    # Call the non-blocking processor
    process_serial_data()

def update_time():
    ts = time.strftime("%I:%M:%S %p")
    canvas.itemconfig(time_text_id, text=ts)
    
    # This is now the main poller for serial data
    process_serial_data() 
    
    root.after(1000, update_time)

root = tk.Tk()
root.title("Smart Watch - Health Monitor")
root.overrideredirect(True)
root.configure(bg="#000000")
canvas = tk.Canvas(root, width=CANVAS_SIZE, height=CANVAS_SIZE, bg="#000000", highlightthickness=0)
canvas.pack(fill=tk.BOTH, expand=True)

bg_photo = create_watch_background(CANVAS_SIZE)
canvas.create_image(0, 0, anchor="nw", image=bg_photo)

time_text_id = canvas.create_text(CENTER - 110, 50, text="", fill="#e6eefb", font=("Segoe UI", 16, "bold"))
battery_text_id = canvas.create_text(CENTER + 110, 50, text="100%", fill="#9eff7a", font=("Segoe UI", 14, "bold"))
canvas.create_text(CENTER, 85, text="HEALTH TRACKER", fill="#bfc7cf", font=("Helvetica", 14, "bold"))

digital_text_id = canvas.create_text(CENTER, CENTER - 40, text="HR: 75 bpm\nSpO2: 98%", fill="#7CFC00", font=("Consolas", 32, "bold"), justify="center")
status_msg_id = canvas.create_text(CENTER, CENTER + 50, text="Safe to drive", fill="#7CFC00", font=("Segoe UI", 15, "bold"), justify="center")

hr_var = tk.IntVar(value=75)
spo2_var = tk.IntVar(value=98)
battery_var = tk.IntVar(value=100)
battery_var_direction = tk.IntVar(value=-1)

rect_x1 = CENTER - 155
rect_y1 = CENTER + 95
rect_x2 = CENTER + 155
rect_y2 = CENTER + 210
rect_bg_id = canvas.create_rectangle(rect_x1, rect_y1, rect_x2, rect_y2, fill="#0d1117", outline="#00FF00", width=3)

hr_label = canvas.create_text(rect_x1 + 12, rect_y1 + 12, text="HR: 75 bpm", fill="#00FF00", font=("Segoe UI", 10, "bold"), anchor="w")
hr_slider = tk.Scale(canvas, from_=30, to=150, orient="horizontal", variable=hr_var, bg="#1a2332", fg="#00FF00", troughcolor="#0d1117", activebackground="#2a4a6a", length=250, highlightthickness=0, bd=0, relief="flat", command=lambda v: update_status())
canvas.create_window(CENTER, rect_y1 + 35, window=hr_slider, width=280)
canvas.create_line(rect_x1 + 8, rect_y1 + 56, rect_x2 - 8, rect_y1 + 56, fill="#00FF00", width=1)

spo2_label = canvas.create_text(rect_x1 + 12, rect_y1 + 68, text="SpO2: 98%", fill="#00FF00", font=("Segoe UI", 10, "bold"), anchor="w")
spo2_slider = tk.Scale(canvas, from_=80, to=100, orient="horizontal", variable=spo2_var, bg="#1a2332", fg="#00FF00", troughcolor="#0d1117", activebackground="#2a4a6a", length=250, highlightthickness=0, bd=0, relief="flat", command=lambda v: update_status())
canvas.create_window(CENTER, rect_y1 + 91, window=spo2_slider, width=280)

update_time()
root.after(100, update_status) 
root.after(500, connect_to_esp32)
root.mainloop()

if ser:
    ser.close()
    print("Serial port closed.")